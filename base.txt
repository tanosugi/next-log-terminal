# Next.js Unified Logger Package

## プロジェクト構造
```
nextjs-unified-logger/
├── src/                    # ソースコード
│   ├── index.ts           # メインエントリーポイント
│   ├── logger.ts          # ロガークラス
│   ├── config.ts          # 設定管理
│   ├── server-action.ts   # サーバーアクション
│   └── types.ts           # 型定義
├── test-app/              # テスト用Next.jsアプリ
│   ├── app/
│   ├── next.config.js
│   └── package.json
├── tests/                 # テストファイル
│   ├── unit/             # Vitestユニットテスト
│   └── e2e/              # Playwrightテスト
├── dist/                  # ビルド出力
├── package.json
├── tsup.config.ts
├── vitest.config.ts
└── playwright.config.ts
```

## ファイル内容

### package.json
```json
{
  "name": "nextjs-unified-logger",
  "version": "1.0.0",
  "description": "Unified logging solution for Next.js with server-side support",
  "main": "./dist/index.js",
  "module": "./dist/index.mjs",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/index.mjs",
      "require": "./dist/index.js",
      "types": "./dist/index.d.ts"
    },
    "./server": {
      "import": "./dist/server.mjs",
      "require": "./dist/server.js",
      "types": "./dist/server.d.ts"
    }
  },
  "files": [
    "dist"
  ],
  "scripts": {
    "dev": "tsup --watch",
    "build": "tsup",
    "test": "vitest",
    "test:e2e": "playwright test",
    "test:all": "npm run test && npm run test:e2e",
    "lint": "eslint src --ext .ts,.tsx",
    "typecheck": "tsc --noEmit",
    "prepublishOnly": "npm run build",
    "dev:test-app": "cd test-app && npm run dev",
    "build:test-app": "cd test-app && npm run build"
  },
  "keywords": [
    "nextjs",
    "logger",
    "logging",
    "server-actions",
    "typescript"
  ],
  "author": "",
  "license": "MIT",
  "peerDependencies": {
    "next": ">=13.4.0",
    "react": ">=18.0.0"
  },
  "devDependencies": {
    "@playwright/test": "^1.40.0",
    "@types/node": "^20.10.0",
    "@types/react": "^18.2.45",
    "@vitejs/plugin-react": "^4.2.1",
    "eslint": "^8.55.0",
    "next": "^14.0.4",
    "react": "^18.2.0",
    "tsup": "^8.0.1",
    "typescript": "^5.3.3",
    "vitest": "^1.1.0"
  }
}
```

### tsup.config.ts
```typescript
import { defineConfig } from 'tsup';

export default defineConfig({
  entry: {
    index: 'src/index.ts',
    server: 'src/server-action.ts',
  },
  format: ['cjs', 'esm'],
  dts: true,
  clean: true,
  sourcemap: true,
  minify: false,
  splitting: false,
  treeshake: true,
  external: ['react', 'next'],
  esbuildOptions(options) {
    options.banner = {
      js: '"use client"',
    };
  },
  onSuccess: async () => {
    // サーバーアクション用のファイルには 'use server' を追加
    const fs = require('fs').promises;
    const serverFiles = ['dist/server.js', 'dist/server.mjs'];
    
    for (const file of serverFiles) {
      try {
        const content = await fs.readFile(file, 'utf-8');
        if (!content.startsWith('"use server"')) {
          await fs.writeFile(file, '"use server";\n' + content.replace('"use client";\n', ''));
        }
      } catch (error) {
        // ファイルが存在しない場合は無視
      }
    }
  },
});
```

### src/types.ts
```typescript
export interface LoggerConfig {
  showTimestamp: boolean;
  showFileName: boolean;
  showLineNumber: boolean;
  showFunctionName: boolean;
  useColors: boolean;
  logLevel: 'error' | 'warn' | 'info' | 'log' | 'debug';
}

export interface LogMetadata {
  timestamp: string;
  fileName?: string;
  lineNumber?: number;
  columnNumber?: number;
  functionName?: string;
  pathname?: string;
  userAgent?: string;
}

export type LogLevel = 'log' | 'info' | 'warn' | 'error';
```

### src/config.ts
```typescript
import type { LoggerConfig } from './types';

const defaultConfig: LoggerConfig = {
  showTimestamp: true,
  showFileName: true,
  showLineNumber: true,
  showFunctionName: false,
  useColors: true,
  logLevel: 'log',
};

export function getLoggerConfig(): LoggerConfig {
  const envConfig: Partial<LoggerConfig> = {
    showTimestamp: process.env.NEXT_PUBLIC_LOG_TIMESTAMP !== 'false',
    showFileName: process.env.NEXT_PUBLIC_LOG_FILENAME !== 'false',
    showLineNumber: process.env.NEXT_PUBLIC_LOG_LINENUMBER !== 'false',
    showFunctionName: process.env.NEXT_PUBLIC_LOG_FUNCTION === 'true',
    useColors: process.env.NEXT_PUBLIC_LOG_COLORS !== 'false',
    logLevel: (process.env.NEXT_PUBLIC_LOG_LEVEL as LoggerConfig['logLevel']) || defaultConfig.logLevel,
  };

  const buildTimeConfig = (globalThis as any).__NEXT_LOGGER_CONFIG__ || {};

  return {
    ...defaultConfig,
    ...buildTimeConfig,
    ...Object.fromEntries(
      Object.entries(envConfig).filter(([_, v]) => v !== undefined)
    ),
  };
}
```

### src/server-action.ts
```typescript
'use server';

import { headers } from 'next/headers';
import { getLoggerConfig } from './config';
import type { LogLevel, LogMetadata } from './types';

export async function serverLog(
  level: LogLevel,
  message: string,
  args: any[],
  metadata: LogMetadata
) {
  const config = getLoggerConfig();
  const headersList = headers();
  const userAgent = headersList.get('user-agent') || 'Unknown';
  
  const colors = {
    log: '\x1b[37m',
    info: '\x1b[36m',
    warn: '\x1b[33m',
    error: '\x1b[31m',
    meta: '\x1b[90m',
  };
  
  const reset = '\x1b[0m';
  const gray = '\x1b[90m';
  
  const levelColor = config.useColors ? colors[level] : '';
  const metaColor = config.useColors ? gray : '';
  const resetColor = config.useColors ? reset : '';
  
  const metaParts = [];
  
  if (config.showTimestamp) {
    metaParts.push(`[${metadata.timestamp}]`);
  }
  
  metaParts.push(`[CLIENT/${level.toUpperCase()}]`);
  
  if (config.showFileName && metadata.fileName) {
    let filePart = metadata.fileName;
    if (config.showLineNumber && metadata.lineNumber) {
      filePart += `:${metadata.lineNumber}`;
      if (metadata.columnNumber) {
        filePart += `:${metadata.columnNumber}`;
      }
    }
    metaParts.push(filePart);
  }
  
  if (config.showFunctionName && metadata.functionName) {
    metaParts.push(`in ${metadata.functionName}()`);
  }
  
  const metaString = metaParts.join(' ');
  console[level](
    `${metaColor}${metaString}${resetColor}`,
    `\n${levelColor}→${resetColor}`,
    message,
    ...args
  );
}
```

### src/logger.ts
```typescript
'use client';

import { serverLog } from './server-action';
import { getLoggerConfig } from './config';
import type { LoggerConfig, LogLevel } from './types';

function extractCallerInfo(): {
  fileName?: string;
  lineNumber?: number;
  columnNumber?: number;
  functionName?: string;
} {
  const error = new Error();
  const stack = error.stack || '';
  const lines = stack.split('\n');
  
  let callerLine = lines[4] || lines[3] || '';
  
  for (let i = 3; i < lines.length; i++) {
    if (!lines[i].includes('webpack-internal:') && 
        !lines[i].includes('unified-logger') &&
        !lines[i].includes('node_modules')) {
      callerLine = lines[i];
      break;
    }
  }
  
  const match = callerLine.match(/at\s+(?:(.+?)\s+\()?(.+?):(\d+):(\d+)\)?/);
  
  if (match) {
    const [, functionName, filePath, lineNumber, columnNumber] = match;
    
    let fileName = filePath;
    if (filePath.includes('webpack-internal:')) {
      const appMatch = filePath.match(/\/\.\/(app\/.+)$/);
      if (appMatch) {
        fileName = appMatch[1];
      }
    } else if (filePath.includes('http://') || filePath.includes('https://')) {
      const urlMatch = filePath.match(/\/([^/]+)$/);
      fileName = urlMatch ? urlMatch[1] : filePath;
    }
    
    return {
      fileName,
      lineNumber: parseInt(lineNumber, 10),
      columnNumber: parseInt(columnNumber, 10),
      functionName: functionName || 'anonymous',
    };
  }
  
  return {};
}

const isServer = typeof window === 'undefined';

const logLevels = {
  error: 0,
  warn: 1,
  info: 2,
  log: 3,
  debug: 4,
};

export class UnifiedLogger {
  private config: LoggerConfig;

  constructor() {
    this.config = getLoggerConfig();
  }

  updateConfig(newConfig: Partial<LoggerConfig>) {
    this.config = { ...this.config, ...newConfig };
  }

  private shouldLog(level: keyof typeof logLevels): boolean {
    return logLevels[level] <= logLevels[this.config.logLevel];
  }

  private getTimestamp(): string {
    const now = new Date();
    const hours = now.getHours().toString().padStart(2, '0');
    const minutes = now.getMinutes().toString().padStart(2, '0');
    const seconds = now.getSeconds().toString().padStart(2, '0');
    const ms = now.getMilliseconds().toString().padStart(3, '0');
    return `${hours}:${minutes}:${seconds}.${ms}`;
  }

  private async logToServer(
    level: LogLevel,
    message: string,
    args: any[]
  ) {
    if (!this.shouldLog(level)) return;

    try {
      const callerInfo = extractCallerInfo();
      const metadata = {
        timestamp: this.getTimestamp(),
        ...callerInfo,
        pathname: typeof window !== 'undefined' ? window.location.pathname : undefined,
      };
      
      await serverLog(level, message, args, metadata);
    } catch (error) {
      console.error('Failed to send log to server:', error);
      console[level](message, ...args);
    }
  }

  private formatServerLog(
    level: string,
    message: string,
    args: any[]
  ): void {
    if (!this.shouldLog(level as keyof typeof logLevels)) return;

    const callerInfo = extractCallerInfo();
    const timestamp = this.getTimestamp();
    
    const colors = {
      log: '\x1b[37m',
      info: '\x1b[36m',
      warn: '\x1b[33m',
      error: '\x1b[31m',
    };
    
    const reset = '\x1b[0m';
    const gray = '\x1b[90m';
    
    const levelColor = this.config.useColors ? colors[level as keyof typeof colors] || colors.log : '';
    const metaColor = this.config.useColors ? gray : '';
    const resetColor = this.config.useColors ? reset : '';
    
    const metaParts = [];
    
    if (this.config.showTimestamp) {
      metaParts.push(`[${timestamp}]`);
    }
    
    metaParts.push(`[SERVER/${level.toUpperCase()}]`);
    
    if (this.config.showFileName && callerInfo.fileName) {
      let filePart = callerInfo.fileName;
      if (this.config.showLineNumber && callerInfo.lineNumber) {
        filePart += `:${callerInfo.lineNumber}`;
        if (callerInfo.columnNumber) {
          filePart += `:${callerInfo.columnNumber}`;
        }
      }
      metaParts.push(filePart);
    }
    
    if (this.config.showFunctionName && callerInfo.functionName) {
      metaParts.push(`in ${callerInfo.functionName}()`);
    }
    
    const metaString = metaParts.join(' ');
    
    console[level as keyof Console](
      `${metaColor}${metaString}${resetColor}`,
      `\n${levelColor}→${resetColor}`,
      message,
      ...args,
      '\n'
    );
  }

  log(message: string, ...args: any[]) {
    if (isServer) {
      this.formatServerLog('log', message, args);
    } else {
      if (this.shouldLog('log')) {
        console.log(message, ...args);
        this.logToServer('log', message, args);
      }
    }
  }

  info(message: string, ...args: any[]) {
    if (isServer) {
      this.formatServerLog('info', message, args);
    } else {
      if (this.shouldLog('info')) {
        console.info(message, ...args);
        this.logToServer('info', message, args);
      }
    }
  }

  warn(message: string, ...args: any[]) {
    if (isServer) {
      this.formatServerLog('warn', message, args);
    } else {
      if (this.shouldLog('warn')) {
        console.warn(message, ...args);
        this.logToServer('warn', message, args);
      }
    }
  }

  error(message: string, ...args: any[]) {
    if (isServer) {
      this.formatServerLog('error', message, args);
    } else {
      if (this.shouldLog('error')) {
        console.error(message, ...args);
        this.logToServer('error', message, args);
      }
    }
  }

  debug(message: string, ...args: any[]) {
    if (this.shouldLog('debug')) {
      const debugMessage = `[DEBUG] ${message}`;
      
      if (isServer) {
        this.formatServerLog('log', debugMessage, args);
      } else {
        console.log(
          `%c[DEBUG]%c ${message}`,
          'color: #6b7280; font-weight: bold;',
          'color: inherit;',
          ...args
        );
        this.logToServer('log', debugMessage, args);
      }
    }
  }
}
```

### src/index.ts
```typescript
export { UnifiedLogger } from './logger';
export { getLoggerConfig } from './config';
export type { LoggerConfig, LogMetadata, LogLevel } from './types';

// デフォルトのロガーインスタンス
import { UnifiedLogger } from './logger';
export const logger = new UnifiedLogger();
```

### vitest.config.ts
```typescript
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: './tests/setup.ts',
  },
});
```

### tests/setup.ts
```typescript
import { beforeEach, vi } from 'vitest';

beforeEach(() => {
  // console メソッドをモック
  global.console = {
    ...console,
    log: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
    group: vi.fn(),
    groupEnd: vi.fn(),
    table: vi.fn(),
  };
});
```

### tests/unit/logger.test.ts
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { UnifiedLogger } from '../../src/logger';

describe('UnifiedLogger', () => {
  let logger: UnifiedLogger;

  beforeEach(() => {
    logger = new UnifiedLogger();
    vi.clearAllMocks();
  });

  describe('Basic logging', () => {
    it('should log messages', () => {
      logger.log('Test message');
      expect(console.log).toHaveBeenCalled();
    });

    it('should log info messages', () => {
      logger.info('Info message');
      expect(console.info).toHaveBeenCalled();
    });

    it('should log warning messages', () => {
      logger.warn('Warning message');
      expect(console.warn).toHaveBeenCalled();
    });

    it('should log error messages', () => {
      logger.error('Error message');
      expect(console.error).toHaveBeenCalled();
    });
  });

  describe('Log levels', () => {
    it('should respect log level settings', () => {
      logger.updateConfig({ logLevel: 'warn' });
      
      logger.debug('Debug message');
      logger.log('Log message');
      logger.info('Info message');
      expect(console.log).not.toHaveBeenCalled();
      expect(console.info).not.toHaveBeenCalled();
      
      logger.warn('Warning message');
      logger.error('Error message');
      expect(console.warn).toHaveBeenCalled();
      expect(console.error).toHaveBeenCalled();
    });
  });

  describe('Configuration', () => {
    it('should update configuration', () => {
      logger.updateConfig({
        showTimestamp: false,
        showFileName: false,
      });
      
      logger.log('Test message');
      expect(console.log).toHaveBeenCalled();
    });
  });
});
```

### tests/unit/config.test.ts
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { getLoggerConfig } from '../../src/config';

describe('Logger Configuration', () => {
  beforeEach(() => {
    vi.resetModules();
    delete process.env.NEXT_PUBLIC_LOG_TIMESTAMP;
    delete process.env.NEXT_PUBLIC_LOG_FILENAME;
    delete process.env.NEXT_PUBLIC_LOG_LEVEL;
  });

  it('should return default configuration', () => {
    const config = getLoggerConfig();
    expect(config).toEqual({
      showTimestamp: true,
      showFileName: true,
      showLineNumber: true,
      showFunctionName: false,
      useColors: true,
      logLevel: 'log',
    });
  });

  it('should read configuration from environment variables', () => {
    process.env.NEXT_PUBLIC_LOG_TIMESTAMP = 'false';
    process.env.NEXT_PUBLIC_LOG_LEVEL = 'error';
    
    const config = getLoggerConfig();
    expect(config.showTimestamp).toBe(false);
    expect(config.logLevel).toBe('error');
  });
});
```

### test-app/package.json
```json
{
  "name": "test-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start"
  },
  "dependencies": {
    "next": "14.0.4",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "nextjs-unified-logger": "file:../"
  },
  "devDependencies": {
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "typescript": "^5"
  }
}
```

### test-app/app/page.tsx
```typescript
import { logger } from 'nextjs-unified-logger';
import ClientComponent from './ClientComponent';

export default function Home() {
  logger.info('Server component rendered');
  
  return (
    <main className="p-8">
      <h1 className="text-2xl mb-4">Logger Test App</h1>
      <ClientComponent />
    </main>
  );
}
```

### test-app/app/ClientComponent.tsx
```typescript
'use client';

import { logger } from 'nextjs-unified-logger';
import { useState } from 'react';

export default function ClientComponent() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    logger.log('Button clicked', { count: count + 1 });
    setCount(count + 1);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button
        onClick={handleClick}
        className="px-4 py-2 bg-blue-500 text-white rounded"
      >
        Click me
      </button>
    </div>
  );
}
```

### test-app/app/actions/logger.ts
```typescript
// Re-export server action from package
export { serverLog } from 'nextjs-unified-logger/server';
```

### playwright.config.ts
```typescript
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './tests/e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
  ],
  webServer: {
    command: 'cd test-app && npm run dev',
    port: 3000,
    reuseExistingServer: !process.env.CI,
  },
});
```

### tests/e2e/logger.spec.ts
```typescript
import { test, expect } from '@playwright/test';

test.describe('Logger E2E Tests', () => {
  test('should log client-side messages', async ({ page }) => {
    // コンソールログを監視
    const consoleLogs: string[] = [];
    page.on('console', (msg) => {
      if (msg.type() === 'log') {
        consoleLogs.push(msg.text());
      }
    });

    await page.goto('/');
    
    // ボタンをクリック
    await page.click('button');
    
    // ログが出力されているか確認
    expect(consoleLogs).toContainEqual(expect.stringContaining('Button clicked'));
  });

  test('should display count correctly', async ({ page }) => {
    await page.goto('/');
    
    // 初期状態を確認
    await expect(page.locator('text=Count: 0')).toBeVisible();
    
    // ボタンを3回クリック
    const button = page.locator('button');
    await button.click();
    await button.click();
    await button.click();
    
    // カウントが更新されているか確認
    await expect(page.locator('text=Count: 3')).toBeVisible();
  });

  test('should handle errors gracefully', async ({ page }) => {
    const errorLogs: string[] = [];
    page.on('console', (msg) => {
      if (msg.type() === 'error') {
        errorLogs.push(msg.text());
      }
    });

    await page.goto('/');
    
    // エラーを発生させる操作があれば実行
    // 例: await page.click('[data-testid="error-button"]');
    
    // エラーハンドリングの確認
  });
});
```

### GitHub Actions設定 (.github/workflows/test.yml)
```yaml
name: Test

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Build package
      run: npm run build
    
    - name: Run unit tests
      run: npm test
    
    - name: Install Playwright
      run: npx playwright install --with-deps
    
    - name: Run E2E tests
      run: npm run test:e2e
    
    - uses: actions/upload-artifact@v3
      if: always()
      with:
        name: playwright-report
        path: playwright-report/
        retention-days: 30
```

### 使用方法
```bash
# 開発
npm install
npm run dev

# テスト
npm test          # Vitestユニットテスト
npm run test:e2e  # PlaywrightのE2Eテスト
npm run test:all  # すべてのテスト

# ビルド
npm run build

# テストアプリの起動
npm run dev:test-app

# パッケージの公開
npm publish
```